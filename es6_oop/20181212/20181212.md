# Desing Pattern & View Pattern 6강 

## MVC
- 컴포지트 패턴 - 한개이상을 모아서 다른 패턴을 만드는것
  - 디자인 패턴의 궁극적인 목적
  - 패턴에 익힌 다음에 패턴을 다시 익히는...
- 모델과 뷰가 직접통신하거나
- 제왕적 컨트롤러를 가지는 패턴 - 컨트롤러 중심의 패턴
- 컨트롤러와 모델(순수한 데이터의 원형)과의 관계
  - 컨트롤러가 어떤 모델과 매핑 되어 있다. 컨트롤러에게 모델을 가져올 책임이 있고
  - 모델에 변화가 있을때 컨트롤러에게 알려줘야 한다. `옵저버 패턴`으로~ 모델은 컨트롤러를 모르므로
- 뷰도 자기가 소비할 모델을 만든다.
  - 사용자 인터랙션을 받아들이는일, 입력받으면 그것을 컨트롤러에게 보고
  - 컨트롤러는 모델에게 업데이트 모델은 다시 컨트롤러에게 보고
- 컨트롤러를 생성한는것은 App
  - 상황에 따라 컨트롤러를 생성
  - 어떤일을 하고 싶다~ 그러면 마땅한 컨트롤러에게 위임

- `모델과 뷰의 변화율은 다르다`
  - 그래서 모델과 뷰를 분리해서 컨트롤러로 변화율을 나눠준것이다.
  - 

## M - ? - V
- 모델의 변화가 일어나고, 뷰가 존재해야하는것은 변함이 없다.

### Model - View - Presenter
- 프리젠터와 뷰와의 통신을 getter, setter로 한다.
  - 뷰는 모델을 모를 뿐더러 소비를 할 수가 없다.
  - 뷰는 일종의 ValueObject다. 
  - 뷰가 컨트롤러를 의존하지 않는다. getter, setter 오픈된 VO일 뿐이다. 알아서 써라, 보내면 보고를 해주마~
  - 뷰가 특정 컨트롤러와 바인딩 되지 않은 VO.
  - 뷰 중심의 개발이 가능한 패턴.
  - 컨트롤러, 모델의 의존성이 제로다~
  - `신속하게 사용자 스토리에 맞는 개발을 가능하게 해줌.`
- `Model - View - (VOprotocol - CommnadProtocol)- Presenter`
  - 프리젠터가 뷰의 인터페이스를 다 알아야 쓸 수 있네...
  - 뷰 하나하나 상대하는것 보다 그룹지어서 상대 할 수 있게 해준다.
  - VO가 너무 커진다.

### Model - View - ViewModel
- 뷰와 뷰모델 서로 옵저빙하고 있다. 서로의 변화에 따라 갱신
  - 양방향 바인딩이 일어난다.
  - 뷰모델에 뷰의 VO 부분만 빼온다. 
  - 뷰모델에서 모델을 번역해서 VO를 갱신하고
  - 엠버...MS에서 MVVM 만든 팀이 나와서 만든 프레임웍



